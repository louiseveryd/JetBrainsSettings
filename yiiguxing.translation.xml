<application>
  <component name="AppStorage">
    <histories>
      <item value="Paths to a kubeconfig. Only required if out-of-cluster" />
      <item value="A SockJS implementation of {@link org.springframework.web.socket.client.WebSocketClient WebSocketClient} with fallback alternatives that simulate a WebSocket interaction through plain HTTP streaming and long polling techniques.. &lt;p&gt;Implements {@link Lifecycle} in order to propagate lifecycle events to the transports it is configured with." />
      <item value="Delegating Web Socket Configuration" />
      <item value="plumber" />
      <item value="An interceptor to check request {@code Origin} header value against a collection of allowed origins." />
      <item value="Attempts to initiate a graceful shutdown of this web socket. Any already-enqueued messages will be transmitted before the close message is sent but subsequent calls to {@link send} will return false and their messages will not be enqueued. &lt;p&gt;This returns true if a graceful shutdown was initiated by this call. It returns false if a graceful shutdown was already underway or if the web socket is already closed or canceled. @param code Status code as defined by &lt;a href=&quot;http:tools.ietf.orghtmlrfc6455section-7.4&quot;&gt;Section 7.4 of RFC 6455&lt;a&gt;. @param reason Reason for shutting down or {@code null}. @throws IllegalArgumentException if code is invalid." />
      <item value="Invoked when both peers have indicated that no more messages will be transmitted and the connection has been successfully released. No further calls to this listener will be made." />
      <item value="Invoked when the remote peer has indicated that no more incoming messages will be transmitted" />
      <item value="This method returns true if the message was enqueued. Messages that would overflow the outgoing message buffer will be rejected and trigger a {@linkplain close graceful shutdown} of this web socket. This method returns false in that case, and in any other case where this web socket is closing, closed, or canceled." />
      <item value="enqueue" />
      <item value="This lock supports a maximum of 65535 recursive write locks and 65535 read locks. Attempts to exceed these limits result in {@link Error} throws from locking methods." />
      <item value="An implementation of {@link ReadWriteLock} supporting similar semantics to {@link ReentrantLock}. &lt;p&gt;This class has the following properties: &lt;ul&gt; &lt;li&gt;&lt;b&gt;Acquisition order&lt;b&gt; &lt;p&gt;This class does not impose a reader or writer preference ordering for lock access. However, it does support an optional &lt;em&gt;fairness&lt;em&gt; policy. &lt;dl&gt; &lt;dt&gt;&lt;b&gt;&lt;i&gt;Non-fair mode (default)&lt;i&gt;&lt;b&gt; &lt;dd&gt;When constructed as non-fair (the default), the order of entry to the read and write lock is unspecified, subject to reentrancy constraints. A nonfair lock that is continuously contended may indefinitely postpone one or more reader or writer threads, but will normally have higher throughput than a fair lock." />
      <item value="&gt;This class does not impose a reader or writer preference ordering for lock access. However, it does support an optional &lt;em&gt;fairness&lt;em&gt; policy. &lt;dl&gt; &lt;dt&gt;&lt;b&gt;&lt;i&gt;Non-fair mode (default)&lt;i&gt;&lt;b&gt; &lt;dd&gt;When constructed as non-fair (the default), the order of entry to the read and write lock is unspecified, subject to reentrancy constraints. A nonfair lock that is continuously contended may indefinitely postpone one or more reader or writer threads, but will normally have higher throughput than a fair lock." />
      <item value="An implementation of {@link ReadWriteLock} supporting similar semantics to {@link ReentrantLock}. &lt;p&gt;This class has the following properties:" />
      <item value="port" />
      <item value="is Running" />
      <item value="The design employs elements of Sequence locks (as used in linux kernels; see Lameter's http:www.lameter.comgelato2005.pdf and elsewhere; see Boehm's http:www.hpl.hp.comtechreports2012HPL-2012-68.html) and Ordered RW locks (see Shirako et al http:dl.acm.orgcitation.cfm?id=2312015)" />
      <item value="JSON Lexer" />
      <item value="cluster" />
      <item value="Ambiguous" />
      <item value="Introspector" />
      <item value="Well-known name for the HandlerMapping object in the bean factory for this namespace. Only used when &quot;detectAllHandlerMappings&quot; is turned off. @see setDetectAllHandlerMappings" />
      <item value="dissection" />
      <item value="Return whether the underlying class is declared within an enclosing class (i.e. the underlying class is an innernested class or a local class within a method). &lt;p&gt;If this method returns {@code false}, then the underlying class is a top-level class." />
      <item value="Determine whether the underlying class is independent, i.e. whether it is a top-level class or a nested class (static inner class) that can be constructed independently from an enclosing class." />
      <item value="Lookup" />
      <item value="An annotation that indicates 'lookup' methods, to be overridden by the container to redirect them back to the {@link org.springframework.beans.factory.BeanFactory} for a {@code getBean} call. This is essentially an annotation-based version of the XML {@code lookup-method} attribute, resulting in the same runtime arrangement. &lt;p&gt;The resolution of the target bean can either be based on the return type ({@code getBean(Class)}) or on a suggested bean name ({@code getBean(String)}), in both cases passing the method's arguments to the {@code getBean} call for applying them as target factory method arguments or constructor arguments. &lt;p&gt;Such lookup methods can have default (stub) implementations that will simply get replaced by the container, or they can be declared as abstract - for the container to fill them in at runtime. In both cases, the container will generate runtime subclasses of the method's containing class via CGLIB, which is why such lookup methods can only work on beans that the container instantiates through regular constructors: i.e. lookup methods cannot get replaced on beans returned from factory methods where we cannot dynamically provide a subclass for them. &lt;p&gt;&lt;b&gt;Concrete limitations in typical Spring configuration scenarios:&lt;b&gt; When used with component scanning or any other mechanism that filters out abstract beans, provide stub implementations of your lookup methods to be able to declare them as concrete classes. And please remember that lookup methods won't work on beans returned from {@code @Bean} methods in configuration classes; you'll have to resort to {@code @Inject Provider&lt;TargetBean&gt;} or the like instead." />
      <item value="concrete" />
      <item value="Return whether the underlying class represents a concrete class," />
      <item value="Return whether the underlying class represents an annotation." />
      <item value="Return whether the underlying class represents an interface." />
      <item value="underlying" />
      <item value="Defines the JVM opcodes, access flags and array type codes. This interface does not define all the JVM opcodes because some opcodes are automatically handled. For example, the xLOAD and xSTORE opcodes are automatically replaced by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and xSTORE_n opcodes are therefore not defined in this interface. Likewise for LDC, automatically replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and JSR_W." />
      <item value="Defines" />
      <item value="register Default Filters" />
      <item value="stereotype annotations" />
      <item value="annotations" />
      <item value="stereotype" />
      <item value="list Target Type Repo" />
      <item value="restrictions" />
      <item value="lifecycle" />
      <item value="Canonical" />
      <item value="do Privileged" />
      <item value="Don't let calling code try to dereference the factory if the bean isn't a factory" />
      <item value="deprecation" />
      <item value="static" />
      <item value="DESC" />
      <item value="offset is not valid" />
      <item value="total Count" />
      <item value="tuple" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1390" />
        <entry key="ENGLISH" value="1391" />
        <entry key="POLISH" value="3" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="2" />
        <entry key="FINNISH" value="4" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="3" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="3" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1607304392356" />
  </component>
</application>