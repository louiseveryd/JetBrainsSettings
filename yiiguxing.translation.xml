<application>
  <component name="AppStorage">
    <histories>
      <item value="CAPACITY" />
      <item value="because the queue may become empty after non-empty and vice versa during SHUTDOWN state, but we can only terminate if, after seeing that it is empty, we see that workerCount is 0 (which sometimes entails a recheck -- see below)." />
      <item value="straightforward" />
      <item value="Detecting the transition from SHUTDOWN to TIDYING is less straightforward than you'd like because the queue may become empty after non-empty and vice versa during SHUTDOWN state, but we can only terminate if, after seeing that it is empty, we see that workerCount is 0 (which sometimes entails a recheck -- see below" />
      <item value="Threads waiting in awaitTermination() will return when the state reaches TERMINATED." />
      <item value="SHUTDOWN -&gt; TIDYING When both queue and pool are empty" />
      <item value="On invocation of shutdown(), perhaps implicitly in finalize() (RUNNING or SHUTDOWN) -&gt; STOP On invocation of shutdownNow()" />
      <item value="On invocation of shutdown(), perhaps implicitly in finalize() (RUNNING or SHUTDOWN) -&gt; STOP" />
      <item value="invocation" />
      <item value="transitions" />
      <item value="The numerical order among these values matters, to allow ordered comparisons. The runState monotonically increases over time, but need not hit each state." />
      <item value="matters" />
      <item value="The numerical order among these values matters, to allow ordered comparisons. The runState monotonically increases over time, but need not hit each state" />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning {@code true} upon success and throwing an {@code IllegalStateException} if no space is currently available. When using a capacity-restricted queue, it is generally preferable to use {@link offer(Object) offer}." />
      <item value="poll" />
      <item value="Reentrant" />
      <item value="transitioning" />
      <item value="conceptual" />
      <item value="The main pool control state, ctl, is an atomic integer packing two conceptual fields workerCount, indicating the effective number of threads runState, indicating whether running, shutting down etc" />
      <item value="entry into" />
      <item value="because existing ones died since last checking" />
      <item value="The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add threads when it shouldn't, by returning false." />
      <item value="Indicates that the same instance of the annotated {@link ChannelHandler} can be added to one or more {@link ChannelPipeline}s multiple times without a race condition. &lt;p&gt; If this annotation is not specified, you have to create a new handler instance every time you add it to a pipeline because it has unshared state such as member variables. &lt;p&gt; This annotation is provided for documentation purpose, just like &lt;a href=&quot;http:www.javaconcurrencyinpractice.comannotationsdoc&quot;&gt;the JCIP annotations&lt;a&gt;." />
      <item value="explicit" />
      <item value="&gt;If you are using an optimizing VM, you may find that ComparableTimSort offers no performance benefit over TimSort in conjunction with a comparator that simply returns {@code ((Comparable)first).compareTo(Second)}. If this is the case, you are better off deleting ComparableTimSort to eliminate the code duplication. (See Arrays.java for details.)" />
      <item value="This is a near duplicate of {@link TimSort}, modified for use with arrays of objects that implement {@link Comparable}, instead of using explicit comparators." />
      <item value="Old merge sort implementation can be selected (for compatibility with broken comparators) using a system property. Cannot be a static boolean in the enclosing class due to circular dependencies. To be removed in a future release." />
      <item value="Handles an IO event or intercepts an IO operation, and forwards it to its next handler in its {@link ChannelPipeline}." />
      <item value="Prints formatted representations of objects to a text-output stream. This class implements all of the &lt;tt&gt;print&lt;tt&gt; methods found in {@link PrintStream}. It does not contain methods for writing raw bytes, for which a program should use unencoded byte streams. &lt;p&gt; Unlike the {@link PrintStream} class, if automatic flushing is enabled it will be done only when one of the &lt;tt&gt;println&lt;tt&gt;, &lt;tt&gt;printf&lt;tt&gt;, or &lt;tt&gt;format&lt;tt&gt; methods is invoked, rather than whenever a newline character happens to be output. These methods use the platform's own notion of line separator rather than the newline character. &lt;p&gt; Methods in this class never throw IO exceptions, although some of its constructors may. The client may inquire as to whether any errors have occurred by invoking {@link checkError checkError()}." />
      <item value="Central class to determine requested {@linkplain MediaType media types} for a request. This is done by delegating to a list of configured {@code ContentNegotiationStrategy} instances." />
      <item value="Negotiation" />
      <item value="Return a variant of this {@code MethodParameter} which points to the same parameter but one nesting level deeper." />
      <item value="Emitter" />
      <item value="Annotation that indicates a method return value should be bound to the web response body. Supported for annotated handler methods." />
      <item value="List" />
      <item value="inherently" />
      <item value="Thread Pool Executor" />
      <item value="SECONDS" />
      <item value="leave" />
      <item value="daemon" />
      <item value="PROCEDURE" />
      <item value="A {@link ChunkedInput} that fetches data from a file chunk by chunk using NIO {@link FileChannel}." />
      <item value="retain" />
      <item value="read Line" />
      <item value="async" />
      <item value="sync" />
      <item value="Override" />
      <item value="exception Caught" />
      <item value="outbound Handler" />
      <item value="fire" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1714" />
        <entry key="ENGLISH" value="1715" />
        <entry key="POLISH" value="3" />
        <entry key="DANISH" value="2" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="2" />
        <entry key="FINNISH" value="4" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="ZULU" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="3" />
        <entry key="HINDI" value="8" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1612142241580" />
  </component>
  <component name="Settings">
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6ee9f602675977e8" />
      </youdao-translate>
    </option>
  </component>
</application>