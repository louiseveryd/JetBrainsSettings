<application>
  <component name="AppStorage">
    <histories>
      <item value="Role hint indicating that a {@code BeanDefinition} is providing an entirely background role and has no relevance to the end-user. This hint is used when registering beans that are completely part of the internal workings of a {@link org.springframework.beans.factory.parsing.ComponentDefinition}." />
      <item value="Role hint indicating that a {@code BeanDefinition} is a supporting part of some larger configuration, typically an outer {@link org.springframework.beans.factory.parsing.ComponentDefinition}. {@code SUPPORT} beans are considered important enough to be aware of when looking more closely at a particular {@link org.springframework.beans.factory.parsing.ComponentDefinition}, but not when looking at the overall configuration of an application." />
      <item value="Role hint indicating that a {@code BeanDefinition} is a supporting part of some larger configuration, typically an outer {@link org.springframework.beans.factory.parsing.ComponentDefinition}. {@code SUPPORT} beans are considered important enough to be aware of when looking more closely at a particular" />
      <item value="corresponds" />
      <item value="If Role is present on a {@link Configuration @Configuration} class, this indicates the role of the configuration class bean definition and does not cascade to all @{@code Bean} methods defined within. This behavior is different than that of the @{@link Lazy} annotation, for example." />
      <item value="If this annotation is not present on a Component or Bean definition, the default value of {@link BeanDefinitionROLE_APPLICATION} will apply." />
      <item value="May be used on any class directly or indirectly annotated with {@link org.springframework.stereotype.Component} or on methods annotated with {@link Bean}." />
      <item value="Indicates the 'role' hint for a given bean." />
      <item value="Role hint indicating that a {@code BeanDefinition} is a major part of the application. Typically corresponds to a user-defined bean." />
      <item value="Allow a subclass to provide custom initialization of the reader, then proceed with actually loading the bean definitions." />
      <item value="Configure the bean definition reader with this context's resource loading environment." />
      <item value="Create a new XmlBeanDefinitionReader for the given BeanFactory." />
      <item value="Beans Exception" />
      <item value="load Bean Definitions" />
      <item value="Load bean definitions into the given bean factory, typically through delegating to one or more bean definition readers." />
      <item value="the bean factory to load bean definitions into" />
      <item value="Set whether to allow circular references between beans - and automatically try to resolve them. &lt;p&gt;Note that circular reference resolution means that one of the involved beans will receive a reference to another bean that is not fully initialized yet. This can lead to subtle and not-so-subtle side effects on initialization; it does work fine for many scenarios, though. &lt;p&gt;Default is &quot;true&quot;. Turn this off to throw an exception when encountering a circular reference, disallowing them completely. &lt;p&gt;&lt;b&gt;NOTE:&lt;b&gt; It is generally recommended to not rely on circular references between your beans. Refactor your application logic to have the two beans involved delegate to a third bean that encapsulates their common logic." />
      <item value="Set whether to allow circular references between beans - and automatically try to resolve them." />
      <item value="Set whether it should be allowed to override bean definitions by registering a different definition with the same name, automatically replacing the former. If not, an exception will be thrown. This also applies to overriding aliases. &lt;p&gt;Default is &quot;true&quot;. @see registerBeanDefinition" />
      <item value="Subclasses must implement this method to perform the actual configuration load. The method is invoked by {@link refresh()} before any other initialization work. &lt;p&gt;A subclass will either create a new bean factory and hold a reference to it, or return a single BeanFactory instance that it holds. In the latter case, it will usually throw an IllegalStateException if refreshing the context more than once." />
      <item value="Subclasses must implement this method to perform the actual configuration load. The method is invoked by {@link refresh()} before any other initialization work. &lt;p&gt;A subclass will either create a new bean factory and hold a reference to it, or return a single BeanFactory instance that it holds. In the latter case, it will usually throw an IllegalStateException if refreshing the context more than once. @throws BeansException if initialization of the bean factory failed @throws IllegalStateException if already initialized and multiple refresh attempts are not supported" />
      <item value="abstract" />
      <item value="Initialize any placeholder property sources in the context environment." />
      <item value="strict" />
      <item value="JAR URL SEPARATOR" />
      <item value="This method will first search the parent class loader for the resource; if the parent is &lt;tt&gt;null&lt;tt&gt; the path of the class loader built-in to the virtual machine is searched. That failing, this method will invoke {@link findResource(String)} to find the resource." />
      <item value="Finds the resource with the given name. A resource is some data (images, audio, text, etc) that can be accessed by class code in a way that is independent of the location of the code." />
      <item value="Hierarchical" />
      <item value="apply Bean Post Processors Before Initialization" />
      <item value="bean" />
      <item value="add Reserve Ips Annotation" />
      <item value="kubernetes" />
      <item value="reservation" />
      <item value="Populate" />
      <item value="Typical methods for creating and populating external bean instances" />
      <item value="Typical" />
      <item value="demarcation" />
      <item value="manual" />
      <item value="args" />
      <item value="Even if" />
      <item value="Eager" />
      <item value="Base class for {@link org.springframework.context.ApplicationContext} implementations which are supposed to support multiple calls to {@link refresh()}, creating a new internal bean factory instance every time. Typically (but not necessarily), such a context will be driven by a set of config locations to load bean definitions from. &lt;p&gt;The only method to be implemented by subclasses is {@link loadBeanDefinitions}, which gets invoked on each refresh. A concrete implementation is supposed to load bean definitions into the given {@link org.springframework.beans.factory.support.DefaultListableBeanFactory}, typically delegating to one or more specific bean definition readers. &lt;p&gt;&lt;b&gt;Note that there is a similar base class for WebApplicationContexts.&lt;b&gt; {@link org.springframework.web.context.support.AbstractRefreshableWebApplicationContext} provides the same subclassing strategy, but additionally pre-implements all context functionality for web environments. There is also a pre-defined way to receive config locations for a web context. &lt;p&gt;Concrete standalone subclasses of this base class, reading in a specific bean definition format, are {@link ClassPathXmlApplicationContext} and {@link FileSystemXmlApplicationContext}, which both derive from the common {@link AbstractXmlApplicationContext} base class; {@link org.springframework.context.annotation.AnnotationConfigApplicationContext} supports {@code @Configuration}-annotated classes as a source of bean definitions." />
      <item value="App Template" />
      <item value="configure Headless Property" />
      <item value="deduce" />
      <item value="Priority" />
      <item value="Extension of the {@link Ordered} interface, expressing a &lt;em&gt;priority&lt;em&gt; ordering: order values expressed by {@code PriorityOrdered} objects always apply before same order values expressed by &lt;em&gt;plain&lt;em&gt; {@link Ordered} objects. &lt;p&gt;This is primarily a special-purpose interface, used for objects where it is particularly important to recognize &lt;em&gt;prioritized&lt;em&gt; objects first, without even obtaining the remaining objects. A typical example: prioritized post-processors in a Spring {@link org.springframework.context.ApplicationContext}." />
      <item value="Override" />
      <item value="remove" />
      <item value="overview" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2315" />
        <entry key="ENGLISH" value="2316" />
        <entry key="ESTONIAN" value="2" />
        <entry key="POLISH" value="4" />
        <entry key="DANISH" value="2" />
        <entry key="GERMAN" value="6" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="4" />
        <entry key="FINNISH" value="5" />
        <entry key="DUTCH" value="2" />
        <entry key="CATALAN" value="4" />
        <entry key="CZECH" value="5" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="ZULU" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="1" />
        <entry key="SLOVAK" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="HAWAIIAN" value="1" />
        <entry key="ITALIAN" value="4" />
        <entry key="HINDI" value="12" />
        <entry key="INDONESIAN" value="3" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1617672818454" />
  </component>
</application>