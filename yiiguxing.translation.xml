<application>
  <component name="AppStorage">
    <histories>
      <item value="Retrieves" />
      <item value="poll" />
      <item value="alternative" />
      <item value="lexer" />
      <item value="Mutex" />
      <item value="omit" />
      <item value="facilitate" />
      <item value="concurrent" />
      <item value="since" />
      <item value="collection" />
      <item value="elements" />
      <item value="type" />
      <item value="dq String Start" />
      <item value="Transport specifies the mechanism by which individual // HTTP requests are made. // If nil, DefaultTransport is used." />
      <item value="struct" />
      <item value="Immutable" />
      <item value="A negative or zero duration causes Sleep to return immediately." />
      <item value="A package-local class holding common representation and mechanics * for classes supporting dynamic striping on 64bit values. The class * extends Number so that concrete subclasses must publicly do so. */" />
      <item value="consumption" />
      <item value="multiplier" />
      <item value="interoperability" />
      <item value="Banner" />
      <item value="istinguishes this * constructor from other int, float constructor." />
      <item value="dummy" />
      <item value="ignored (distinguishes this * constructor from other int, float constructor.)" />
      <item value="mechanism" />
      <item value="General purpose factory loading mechanism for internal use within the framework." />
      <item value="traversals" />
      <item value="Sequential" />
      <item value="Parallel" />
      <item value="Indicates that this collector is &lt;em&gt;concurrent&lt;/em&gt;, meaning that * the result container can support the accumulator function being * called concurrently with the same result container from multiple * threads." />
      <item value="Indicates that this collector is &lt;em&gt;concurrent&lt;/em&gt;, meaning that * the result container can support the accumulator function being * called concurrently with the same result container from multiple * threads. * * &lt;p&gt;If a {@code CONCURRENT} collector is not also {@code UNORDERED}, * then it should only be evaluated concurrently if applied to an * unordered data source." />
      <item value="Indicates that the collection operation does not commit to preserving * the encounter order of input elements. (This might be true if the * result container has no intrinsic order, such as a {@link Set}.)" />
      <item value="Indicates that the finisher function is the identity function and * can be elided. If set, it must be the case that an unchecked cast * from A to R will succeed." />
      <item value="Decimal" />
      <item value="transient" />
      <item value="enqueue" />
      <item value="Inserts element at current put position, advances, and signals. * Call only when holding lock." />
      <item value="Concurrency control uses the classic two-condition algorithm * found in any textbook." />
      <item value="This class and its iterator implement all of the * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link * Iterator} interfaces." />
      <item value="This class supports an optional fairness policy for ordering * waiting producer and consumer threads. By default, this ordering * is not guaranteed. However, a queue constructed with fairness set * to {@code true} grants threads access in FIFO order. Fairness * generally decreases throughput but reduces variability and avoids * starvation." />
      <item value="&lt;p&gt;This is a classic &amp;quot;bounded buffer&amp;quot;, in which a * fixed-sized array holds elements inserted by producers and * extracted by consumers. Once created, the capacity cannot be * changed. Attempts to {@code put} an element into a full queue * will result in the operation blocking; attempts to {@code take} an * element from an empty queue will similarly block." />
      <item value="* A bounded {@linkplain BlockingQueue blocking queue} backed by an * array. This queue orders elements FIFO (first-in-first-out). The * &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the * queue the longest time. The &lt;em&gt;tail&lt;/em&gt; of the queue is that * element that has been on the queue the shortest time. New elements * are inserted at the tail of the queue, and the queue retrieval * operations obtain elements at the head of the queue." />
      <item value="elapses" />
      <item value="inhibit" />
      <item value="Null Pointer Exception" />
      <item value="first Task" />
      <item value="enqueues" />
      <item value="public" />
      <item value="void" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="924" />
        <entry key="ENGLISH" value="911" />
        <entry key="POLISH" value="1" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="2" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="PORTUGUESE" value="3" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6ee9f602675977e8" />
      </youdao-translate>
    </option>
  </component>
</application>