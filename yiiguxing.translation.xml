<application>
  <component name="AppStorage">
    <histories>
      <item value="Handles an IO event or intercepts an IO operation, and forwards it to its next handler in its {@link ChannelPipeline}." />
      <item value="Prints formatted representations of objects to a text-output stream. This class implements all of the &lt;tt&gt;print&lt;tt&gt; methods found in {@link PrintStream}. It does not contain methods for writing raw bytes, for which a program should use unencoded byte streams. &lt;p&gt; Unlike the {@link PrintStream} class, if automatic flushing is enabled it will be done only when one of the &lt;tt&gt;println&lt;tt&gt;, &lt;tt&gt;printf&lt;tt&gt;, or &lt;tt&gt;format&lt;tt&gt; methods is invoked, rather than whenever a newline character happens to be output. These methods use the platform's own notion of line separator rather than the newline character. &lt;p&gt; Methods in this class never throw IO exceptions, although some of its constructors may. The client may inquire as to whether any errors have occurred by invoking {@link checkError checkError()}." />
      <item value="Central class to determine requested {@linkplain MediaType media types} for a request. This is done by delegating to a list of configured {@code ContentNegotiationStrategy} instances." />
      <item value="Negotiation" />
      <item value="Return a variant of this {@code MethodParameter} which points to the same parameter but one nesting level deeper." />
      <item value="Emitter" />
      <item value="Annotation that indicates a method return value should be bound to the web response body. Supported for annotated handler methods." />
      <item value="List" />
      <item value="inherently" />
      <item value="Thread Pool Executor" />
      <item value="SECONDS" />
      <item value="leave" />
      <item value="daemon" />
      <item value="PROCEDURE" />
      <item value="A {@link ChunkedInput} that fetches data from a file chunk by chunk using NIO {@link FileChannel}." />
      <item value="retain" />
      <item value="read Line" />
      <item value="async" />
      <item value="sync" />
      <item value="Override" />
      <item value="exception Caught" />
      <item value="outbound Handler" />
      <item value="fire" />
      <item value="Channel Inbound Handler" />
      <item value="Internally, a {@link FastThreadLocal} uses a constant index in an array, instead of using hash code and hash table, to look for a variable. Although seemingly very subtle, it yields slight performance advantage over using a hash table, and it is useful when accessed frequently. &lt;p&gt;&lt;p&gt; To take advantage of this thread-local variable, your thread must be a {@link FastThreadLocalThread} or its subtype. By default, all threads created by {@link DefaultThreadFactory} are {@link FastThreadLocalThread} due to this reason. &lt;p&gt;&lt;p&gt; Note that the fast path is only possible on threads that extend {@link FastThreadLocalThread}, because it requires a special field to store the necessary state. An access by any other kind of thread falls back to a regular {@link ThreadLocal}." />
      <item value="A special variant of {@link ThreadLocal} that yields higher access performance when accessed from a {@link FastThreadLocalThread}." />
      <item value="session" />
      <item value="returns" />
      <item value="Default Byte Buf Holder" />
      <item value="sanity" />
      <item value="on-the-fly" />
      <item value="Codec" />
      <item value="Aggregator" />
      <item value="Replaying Decoder" />
      <item value="REPLAY" />
      <item value="Called when the input of the channel was closed which may be because it changed to inactive or because of {@link ChannelInputShutdownEvent}." />
      <item value="Channel Handler Context" />
      <item value="Exception" />
      <item value="Object" />
      <item value="decode Last" />
      <item value="decode" />
      <item value="abstract" />
      <item value="Channel Pipeline" />
      <item value="second" />
      <item value="pipeline" />
      <item value="readable Bytes" />
      <item value="For example here is an implementation which reads all readable bytes from the input {@link ByteBuf} and create a new {@link ByteBuf}." />
      <item value="{@link ChannelInboundHandlerAdapter} which decodes bytes in a stream-like fashion from one {@link ByteBuf} to an other Message type." />
      <item value="discardable" />
      <item value="Http Request Encoder" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1686" />
        <entry key="ENGLISH" value="1687" />
        <entry key="POLISH" value="3" />
        <entry key="DANISH" value="2" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="2" />
        <entry key="FINNISH" value="4" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="ZULU" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="3" />
        <entry key="HINDI" value="8" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1612142241580" />
  </component>
  <component name="Settings">
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6ee9f602675977e8" />
      </youdao-translate>
    </option>
  </component>
</application>