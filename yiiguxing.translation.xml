<application>
  <component name="AppStorage">
    <histories>
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning {@code true} upon success and throwing an {@code IllegalStateException} if no space is currently available. When using a capacity-restricted queue, it is generally preferable to use {@link offer(Object) offer}." />
      <item value="poll" />
      <item value="Reentrant" />
      <item value="transitioning" />
      <item value="conceptual" />
      <item value="The main pool control state, ctl, is an atomic integer packing two conceptual fields workerCount, indicating the effective number of threads runState, indicating whether running, shutting down etc" />
      <item value="entry into" />
      <item value="because existing ones died since last checking" />
      <item value="The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add threads when it shouldn't, by returning false." />
      <item value="Indicates that the same instance of the annotated {@link ChannelHandler} can be added to one or more {@link ChannelPipeline}s multiple times without a race condition. &lt;p&gt; If this annotation is not specified, you have to create a new handler instance every time you add it to a pipeline because it has unshared state such as member variables. &lt;p&gt; This annotation is provided for documentation purpose, just like &lt;a href=&quot;http:www.javaconcurrencyinpractice.comannotationsdoc&quot;&gt;the JCIP annotations&lt;a&gt;." />
      <item value="explicit" />
      <item value="&gt;If you are using an optimizing VM, you may find that ComparableTimSort offers no performance benefit over TimSort in conjunction with a comparator that simply returns {@code ((Comparable)first).compareTo(Second)}. If this is the case, you are better off deleting ComparableTimSort to eliminate the code duplication. (See Arrays.java for details.)" />
      <item value="This is a near duplicate of {@link TimSort}, modified for use with arrays of objects that implement {@link Comparable}, instead of using explicit comparators." />
      <item value="Old merge sort implementation can be selected (for compatibility with broken comparators) using a system property. Cannot be a static boolean in the enclosing class due to circular dependencies. To be removed in a future release." />
      <item value="Handles an IO event or intercepts an IO operation, and forwards it to its next handler in its {@link ChannelPipeline}." />
      <item value="Prints formatted representations of objects to a text-output stream. This class implements all of the &lt;tt&gt;print&lt;tt&gt; methods found in {@link PrintStream}. It does not contain methods for writing raw bytes, for which a program should use unencoded byte streams. &lt;p&gt; Unlike the {@link PrintStream} class, if automatic flushing is enabled it will be done only when one of the &lt;tt&gt;println&lt;tt&gt;, &lt;tt&gt;printf&lt;tt&gt;, or &lt;tt&gt;format&lt;tt&gt; methods is invoked, rather than whenever a newline character happens to be output. These methods use the platform's own notion of line separator rather than the newline character. &lt;p&gt; Methods in this class never throw IO exceptions, although some of its constructors may. The client may inquire as to whether any errors have occurred by invoking {@link checkError checkError()}." />
      <item value="Central class to determine requested {@linkplain MediaType media types} for a request. This is done by delegating to a list of configured {@code ContentNegotiationStrategy} instances." />
      <item value="Negotiation" />
      <item value="Return a variant of this {@code MethodParameter} which points to the same parameter but one nesting level deeper." />
      <item value="Emitter" />
      <item value="Annotation that indicates a method return value should be bound to the web response body. Supported for annotated handler methods." />
      <item value="List" />
      <item value="inherently" />
      <item value="Thread Pool Executor" />
      <item value="SECONDS" />
      <item value="leave" />
      <item value="daemon" />
      <item value="PROCEDURE" />
      <item value="A {@link ChunkedInput} that fetches data from a file chunk by chunk using NIO {@link FileChannel}." />
      <item value="retain" />
      <item value="read Line" />
      <item value="async" />
      <item value="sync" />
      <item value="Override" />
      <item value="exception Caught" />
      <item value="outbound Handler" />
      <item value="fire" />
      <item value="Channel Inbound Handler" />
      <item value="Internally, a {@link FastThreadLocal} uses a constant index in an array, instead of using hash code and hash table, to look for a variable. Although seemingly very subtle, it yields slight performance advantage over using a hash table, and it is useful when accessed frequently. &lt;p&gt;&lt;p&gt; To take advantage of this thread-local variable, your thread must be a {@link FastThreadLocalThread} or its subtype. By default, all threads created by {@link DefaultThreadFactory} are {@link FastThreadLocalThread} due to this reason. &lt;p&gt;&lt;p&gt; Note that the fast path is only possible on threads that extend {@link FastThreadLocalThread}, because it requires a special field to store the necessary state. An access by any other kind of thread falls back to a regular {@link ThreadLocal}." />
      <item value="A special variant of {@link ThreadLocal} that yields higher access performance when accessed from a {@link FastThreadLocalThread}." />
      <item value="session" />
      <item value="returns" />
      <item value="Default Byte Buf Holder" />
      <item value="sanity" />
      <item value="on-the-fly" />
      <item value="Codec" />
      <item value="Aggregator" />
      <item value="Replaying Decoder" />
      <item value="REPLAY" />
      <item value="Called when the input of the channel was closed which may be because it changed to inactive or because of {@link ChannelInputShutdownEvent}." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1701" />
        <entry key="ENGLISH" value="1702" />
        <entry key="POLISH" value="3" />
        <entry key="DANISH" value="2" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="2" />
        <entry key="FINNISH" value="4" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="ZULU" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="3" />
        <entry key="HINDI" value="8" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1612142241580" />
  </component>
  <component name="Settings">
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6ee9f602675977e8" />
      </youdao-translate>
    </option>
  </component>
</application>