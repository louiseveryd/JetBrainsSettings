<application>
  <component name="AppStorage">
    <histories>
      <item value="cluster Id" />
      <item value="Synonym" />
      <item value="MAX POLL RECORDS CONFIG" />
      <item value="interval" />
      <item value="&quot;The maximum delay between invocations of poll() when using &quot; + &quot;consumer group management. This places an upper bound on the amount of time that the consumer can be idle &quot; + &quot;before fetching more records. If poll() is not called before expiration of this timeout, then the consumer &quot; + &quot;is considered failed and the group will rebalance in order to reassign the partitions to another member. &quot; + &quot;For consumers using a non-null &lt;code&gt;group.instance.id&lt;/code&gt; which reach this timeout, partitions will not be immediately reassigned. &quot; + &quot;Instead, the consumer will stop sending heartbeats and partitions will be reassigned &quot; + &quot;after expiration of &lt;code&gt;session.timeout.ms&lt;/code&gt;. This mirrors the behavior of a static consumer which has shutdown.&quot;;" />
      <item value="The maximum delay between invocations of poll() when using &quot; + &quot;consumer group management. This places an upper bound on the amount of time that the consumer can be idle &quot; + &quot;before fetching more records. If poll() is not called before expiration of this timeout, then the consumer &quot; + &quot;is considered failed and the group will rebalance in order to reassign the partitions to another member. &quot; + &quot;For consumers using a non-null &lt;code&gt;group.instance.id&lt;/code&gt; which reach this timeout, partitions will not be immediately reassigned. &quot; + &quot;Instead, the consumer will stop sending heartbeats and partitions will be reassigned &quot; + &quot;after expiration of &lt;code&gt;session.timeout.ms&lt;/code&gt;. This mirrors the behavior of a static consumer which has shutdown" />
      <item value="last Record" />
      <item value="cached Record Exception" />
      <item value="deserialization" />
      <item value="corrupt" />
      <item value="fetched Records" />
      <item value="propagate" />
      <item value="milliseconds" />
      <item value="Out Of" />
      <item value="End Offset" />
      <item value="Offset Out Of End Offset Range Exception" />
      <item value="seek" />
      <item value="The maximum amount of time to await retrieval of the beginning offsets" />
      <item value="a mapping from partition to the timestamp and offset of the first message with timestamp greater * than or equal to the target timestamp. {@code null} will be returned for the partition if there is no * such message." />
      <item value="This is a blocking call. The consumer does not have to be assigned the partitions. * If the message format version in a partition is before 0.10.0, i.e. the messages do not have timestamps, null * will be returned for that partition." />
      <item value="Look up the offsets for the given partitions by timestamp. The returned offset for each partition is the * earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition." />
      <item value="offsets For Times" />
      <item value="on Partitions Assigned" />
      <item value="on Partitions Revoked" />
      <item value="case" />
      <item value="switch" />
      <item value="optimize" />
      <item value="unmarshal" />
      <item value="Negative" />
      <item value="Sequence Input Stream" />
      <item value="Sequence" />
      <item value="dim Delete" />
      <item value="exposure" />
      <item value="is Parallel" />
      <item value="Evictor" />
      <item value="liurui" />
      <item value="surefire" />
      <item value="absent" />
      <item value="parameterized" />
      <item value="bocloud" />
      <item value="pipeline" />
      <item value="separator" />
      <item value="discovery" />
      <item value="May be used on any class directly or indirectly annotated with * {@code @Component} or on methods annotated with @{@link Bean}." />
      <item value="Because {@code HibernateFooRepository} is marked with {@code @Primary}, * it will be injected preferentially over the jdbc-based variant assuming both * are present as beans within the same Spring application context, which is * often the case when component-scanning is applied liberally." />
      <item value="UNSTABLE" />
      <item value="LOGGER" />
      <item value="slot" />
      <item value="Assemble" />
      <item value="reified" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1335" />
        <entry key="ENGLISH" value="1303" />
        <entry key="POLISH" value="3" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="2" />
        <entry key="FINNISH" value="3" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="3" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="3" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6ee9f602675977e8" />
      </youdao-translate>
    </option>
  </component>
</application>