<application>
  <component name="AppStorage">
    <histories>
      <item value="JSON Lexer" />
      <item value="cluster" />
      <item value="Ambiguous" />
      <item value="Introspector" />
      <item value="Well-known name for the HandlerMapping object in the bean factory for this namespace. Only used when &quot;detectAllHandlerMappings&quot; is turned off. @see setDetectAllHandlerMappings" />
      <item value="dissection" />
      <item value="Return whether the underlying class is declared within an enclosing class (i.e. the underlying class is an innernested class or a local class within a method). &lt;p&gt;If this method returns {@code false}, then the underlying class is a top-level class." />
      <item value="Determine whether the underlying class is independent, i.e. whether it is a top-level class or a nested class (static inner class) that can be constructed independently from an enclosing class." />
      <item value="Lookup" />
      <item value="An annotation that indicates 'lookup' methods, to be overridden by the container to redirect them back to the {@link org.springframework.beans.factory.BeanFactory} for a {@code getBean} call. This is essentially an annotation-based version of the XML {@code lookup-method} attribute, resulting in the same runtime arrangement. &lt;p&gt;The resolution of the target bean can either be based on the return type ({@code getBean(Class)}) or on a suggested bean name ({@code getBean(String)}), in both cases passing the method's arguments to the {@code getBean} call for applying them as target factory method arguments or constructor arguments. &lt;p&gt;Such lookup methods can have default (stub) implementations that will simply get replaced by the container, or they can be declared as abstract - for the container to fill them in at runtime. In both cases, the container will generate runtime subclasses of the method's containing class via CGLIB, which is why such lookup methods can only work on beans that the container instantiates through regular constructors: i.e. lookup methods cannot get replaced on beans returned from factory methods where we cannot dynamically provide a subclass for them. &lt;p&gt;&lt;b&gt;Concrete limitations in typical Spring configuration scenarios:&lt;b&gt; When used with component scanning or any other mechanism that filters out abstract beans, provide stub implementations of your lookup methods to be able to declare them as concrete classes. And please remember that lookup methods won't work on beans returned from {@code @Bean} methods in configuration classes; you'll have to resort to {@code @Inject Provider&lt;TargetBean&gt;} or the like instead." />
      <item value="concrete" />
      <item value="Return whether the underlying class represents a concrete class," />
      <item value="Return whether the underlying class represents an annotation." />
      <item value="Return whether the underlying class represents an interface." />
      <item value="underlying" />
      <item value="Defines the JVM opcodes, access flags and array type codes. This interface does not define all the JVM opcodes because some opcodes are automatically handled. For example, the xLOAD and xSTORE opcodes are automatically replaced by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and xSTORE_n opcodes are therefore not defined in this interface. Likewise for LDC, automatically replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and JSR_W." />
      <item value="Defines" />
      <item value="register Default Filters" />
      <item value="stereotype annotations" />
      <item value="annotations" />
      <item value="stereotype" />
      <item value="list Target Type Repo" />
      <item value="restrictions" />
      <item value="lifecycle" />
      <item value="Canonical" />
      <item value="do Privileged" />
      <item value="Don't let calling code try to dereference the factory if the bean isn't a factory" />
      <item value="deprecation" />
      <item value="static" />
      <item value="DESC" />
      <item value="offset is not valid" />
      <item value="total Count" />
      <item value="tuple" />
      <item value="Constant Future" />
      <item value="throws" />
      <item value="write Lock Supplier" />
      <item value="read Lock Supplier" />
      <item value="Stamped" />
      <item value="SNAPSHOT" />
      <item value="surefire" />
      <item value="slices" />
      <item value="retry" />
      <item value="is Parallel" />
      <item value="Pagination Interceptor Auto Configuration" />
      <item value="Paginatio" />
      <item value="implements" />
      <item value="Finchley" />
      <item value="Override" />
      <item value="consumer" />
      <item value="page Size" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1385" />
        <entry key="ENGLISH" value="1372" />
        <entry key="POLISH" value="3" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="2" />
        <entry key="FINNISH" value="4" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="3" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="3" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1607304392356" />
  </component>
</application>